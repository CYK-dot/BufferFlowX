# TR1. 设计目标
针对多个常见场景，提供一个从基础到全面的命令行开发框架，并且均支持裁剪。
## 1. 场景
1. unix-like/view命令行
    - 尽可能高的人机交互效率：例如：视图切换、命令提示、异步执行、控制字符处理
    - 尽可能简单的开发难度，并且允许功能裁剪
2. at命令行
    - 通过串口交互，不处理回显
    - 尽可能低的flash/ram占用
3. 仅命令匹配
    - 希望自己实现命令行封装，仅使用框架提供的匹配功能
## 2. 场景分析
1. at命令行相当于在命令行匹配的基础上做简单包装：
    - 提供命令注册接口
    - 字节流分词
    - 在命令匹配后，调用回调
2. view命令行相当于在at命令行之上再做若干层包装
    - 输入回显
    - 命令补全/提示词切换/异步执行
    - 控制序列处理
3. unix-like命令行又相当于在view命令行之上封装提示词切换逻辑
    - DSL描述视图切换逻辑
    - 通过分隔符/描述对象的继承关系，并固化为接口
因此三个场景不应割裂，而应递进分析。
- 从实现的角度上，从仅命令匹配一路实现到view命令行。
- 从目标的角度上，从view命令行开始拆解黑盒功能点，直到仅命令匹配。
## 3. 目标拆解与第一性分析
1. view命令行目标拆解
    - 视图
        - 视图分为两部分，声明与动作
        - 视图通过DSL声明，分为动态与静态
        - 命令、控制字符均可以触发视图动作（创建、删除、切换、提交）
        - 静态视图仅支持切换这一种动作
        - 动态视图完整支持创建、切换、删除、提交三种动作
        - 支持通过函数接口查询当前动态视图的情况
    - 命令声明
        - 静态声明，通过与视图绑定实现动态加载
        - 支持关键字与参数
        - 参数不指定数据类型，由用户自行确保
    - 命令提示
        - 通过tab或问号可以触发命令提示
        - 找不到匹配命令/匹配多个命令时，需要指出哪里填错了，错的是什么原因
        - 当匹配结果只有一个时，支持命令缩写
    - 控制序列
        - 上下左右方向键
        - 退格回车
        - ctrl+字母
    - 异步回显
        - 支持escape转义回显，例如光标、颜色控制
        - 应用程序与命令行前端轮流使用回显
        - 应用程序只能被动拿到锁
        - 命令行前端允许让锁和抢锁（例如输入ctrl+c）
2. view命令行第一性分析
    - 到底有没有必要提供视图功能？
        - 有的，因为视图/提示词 实际上指示了用户当前正在操作的对象，例如网络设备的\[vlan1\]抑或是unix的/etc/hosts
        - 换言之，提供视图的目的是让命令行具备对象管理能力，尤其是动态对象管理，这是原始命令行无法实现的。
3. at命令行目标拆解
    与其说at命令行是命令行，不如说他其实是一种特殊的通信方式，要按通信协议的方式分析
    - 分词/成帧
        - 包头可以不存在，或由用户指定，让at命令可以运行在物理层上
        - 包尾兼容\r \n \r\n \n\r，不应要求用户指定任意一种
    - 命令声明
        - 支持ascii命令表达式但不支持二进制命令表达式
        - 表达式支持参数，但不支持可选参数
    - 多路复用
        - 命令解析器作为服务器，通信接口作为客户端，实现命令行同时在多个端口上生效
        - 命令服务器全局唯一
4. at命令行第一性分析
    - 为什么不应支持二进制表达式？
        - 二进制表达式容易出现转义冲突，规避转义冲突带来的好处小于换成ascii数据包带来的好处。
        - 二进制表达式除了省带宽，看不到有什么优势。
    - 为啥不应该支持多AT服务器？
        - 因为在at之上的view命令行可以实现同样的功能。如果at命令行支持多服务器，那么就与view命令行产生了功能冲突。
        - 除此之外，view也需要通过父类索引的方式获取命令，公共命令就是所有对象的根节点。

# TR2. 需要实现的功能点
## bfx_cli_core
组件实现
1. 给定命令行表达式、待匹配命令，获取是否匹配，以及匹配结果（参数有几个，在哪）

## bfx_section
组件说明
|--------------------------|
|        业务C代码           |
|--------------------------|
| bfx_section(c)(generate) |       
|--------------------------|    <--- ld和C代码分界线
|      全局linker.ld        |
|--------------------------|
|       业务模块(ld)         |
|--------------------------|
|     bfx_section(ld)      |
|--------------------------|
层次关系如上所示，应该要这么理解
- 链接脚本在所有的C代码之下，有自己的层次结构
- 链接脚本最顶层只能有一个接口，也即全局linker.ld
- 顶层linker.ld为C模块提供地址和符号，如果C模块需要新的段/符号，则应通过依赖注入的方式，注入到业务模块中。

组件实现
1. 提供链接脚本宏，只要使用者在主链接脚本中引用该宏定义一个段，就能在C代码中：
    - 将函数/变量放到段中
    - 访问段的长度、起点、终点
2. 链接脚本宏分为两种，集中式和分散式。集中式的需要在顶层ld中调用，分散式的直接在组件的bfx.yml配置中编写。

## bfx_cli_at
组件说明
1. 分为两个子模块，服务器与客户端。服务器提供命令解析与执行服务，客户端负责分词、转发执行结果。
2. 服务器全局唯一，由若干个命令实例构成。命令实例分散定义，包含命令回调、表达式。
3. 客户端由框架使用者实现，服务器由框架提供。
组件实现
1. 服务器模块，提供命令注册宏，接收命令实例传入的描述符，将其存放到flash中的固定段中。
2. 服务器模块，提供订阅接口，客户端传入命令、输出缓冲区及其长度，由服务器解析命令后，将参数和缓冲区转发到命令实例。
3. 服务器模块，提供维护接口，可供查询命令描述符。

# functions
## BFX_CliRawMatch
paramStore的复用：
1. 在计算fmt的token总数时，临时存放fmt的token索引，但并不使用
2. 存放cmd的token索引。
3. 存放cmd的paramToken索引。
其中，1和23不可能同时发生，因此复用是没问题的。
注意到，param总数总是<=token总数，因此在遍历所有token时，修改内容总不会超过当前迭代器，因此23也是可以复用的。