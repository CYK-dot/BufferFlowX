# TR1. 设计目标
提供一个跨平台的段管理中间件
## 1. 第一性分析
- 是要求使用者分散定义段，还是集中定义段？
    - 这是个共性问题：如果组件要在公共机制上做定制，应该把定制的部分放到公共，还是放到组件内部？
    - 可以使用“不额外感知”原则来分析这个共性问题。
    - 如果该组件的定制需要被其他组件感知，那么应该呈现为公共；如果只有组件自己感知，那么不应该公共。
    - 但是，这里就引发了一个问题。如果该组件的定制需要被其他组件感知，那为什么其他组件不直接依赖于该组件呢？
    - 因此，从内聚的角度来说，定制内容就应该放在定制该内容的组件中，并由该组件对定制进行封装。
## 2. 目标拆解
运作流程如下

两步配置
1. 用户把py脚本添加到预编译流程，脚本参数有四个：模板ld所在的目录、模板ld脚本类型（gcc/keil）、项目根目录、输出ld目录
2. 用户把输出ld脚本设置为主链接脚本
三步运行
3. 触发编译时，py脚本先读取模板ld，输出bfx_region.txt到输出ld目录
4. 然后，py脚本遍历项目根目录，读取bfx.yml文件，结合文件内容和bfx_region.txt，在组件下生成bfx_section_xxx.h头文件
5. 遍历完所有组件后，py脚本输出最终的ld脚本
6. 开始编译C码

# TR2. 需要实现的功能点

## 1. bfx.yml编写方式

```yaml
name: 组件名(可选)
section:
    - name: 段名1
        region: 段所在的区域(必选)
        align: 段对齐(可选)
        address: 段起始地址(可选)
        size: 段大小(可选)
    - name: 段名2
        region: 段所在的区域(必选)
        align: 段对齐(可选)
        address: 段起始地址(可选)
        size: 段大小(可选)
```