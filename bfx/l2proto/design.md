# 一、L2协议设计目标
为原始通信接口（特指SPI/UART）提供高度可定制的二层协议栈。
二层协议的目标
- 成帧与同步
- 差错控制
- 寻址
- 访问控制
考虑到寻址可以交给三层协议实现，访问控制较难统一接口，因此此处只实现前两者。

# 二、L2协议原始需求
## 1. 成帧与同步
- 帧头信息开放可定制
- 同步措施确保灵活
- 帧长可定制
## 2. 差错控制
- 校验长度开放可定制
- 校验方式开放可定制

# 三、L2协议需求分解
## 1. 成帧与同步
帧头信息实际上可以由用户在三层实现，L2协议应确保尽可能精简。
借鉴以太网的同步措施，帧头前可自定义同步序列，序列开放可定制。

## 2. 差错控制

# 四、L2协议设计
| 前导同步序列 | L2帧头 | 数据 | FCS |
其中，L2帧头长度可配置，分为引导头+数据长度，用户可配置数据长度占有多少个比特，剩余部分作为引导头，填充全1。
例如，配置帧头长度为3字节，数据长度最长为257，则L2帧头实际为
| 0~15b | 16~23b |
| 全1   | 数据长度 |
配置由通信双方预先给定，不通过协商获取，保持协议的精简性。
注意到，在一个字节内做前导序列，序列后跟着数据长度，本质上无法实现前导序列的功能，因为无法达到区分“帧头”与“数据”的目的。
既然如此，那不如直接强制要求前导序列的最小单位为字节，并且不再让前导序列侵入数据长度字段。
这就引发了另一个问题：多出来的空间怎么用？此时就可以引入用户字段了，他不再因为“把事情复杂化”而被裁剪。
最终设计：
| 前导同步序列 | 用户比特 | 数据长度 | 数据 | FCS |
但是，字节压缩这件事同样要受到质疑：他带来的好处是否压过了缺点？
很容易推导出边界：解析花的时间不能大过一个字节发送的时间。
